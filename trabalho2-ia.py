# -*- coding: utf-8 -*-
"""trabalho2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1O9gVcGbfkBy2GYhVxaiJYGhs_fR5IRMP
"""

class Conecta4:
    """
    Classe que implementa o jogo Conecta 4 em um tabuleiro 5x5,
    com jogador humano ('X') e uma IA ('O') utilizando o algoritmo MinMax com poda alfa-beta.
    """
    def __init__(self):
        """
        Inicializa o tabuleiro, define o jogador atual como 'X' (humano) e
        define os pesos usados na avaliação do tabuleiro pela IA.
        """
        self.tabuleiro = [[' ' for _ in range(5)] for _ in range(5)]
        self.jogador_atual = 'X'
        # Pesos ajustáveis via algoritmo genético
        self.pesos = {
          'duplas': 1.0,
          'trincas': 5.0,
          'centro': 2.0,
          'potencial_vitoria': 10.0
        }

    def imprimir_tabuleiro(self):
        """
        Imprime o tabuleiro atual no console.
        """
        for linha in self.tabuleiro:
            print('|'.join(linha))
        print("-" * 9)

    def ações_possíveis(self):
        """
        Retorna uma lista de todas as posições (linha, coluna) ainda não ocupadas.

        Returns:
            list: Lista de tuplas (linha, coluna).
        """
        return [(linha, coluna) for linha in range(5) for coluna in range(5) if self.tabuleiro[linha][coluna] == ' ']

    def fazer_jogada(self, linha, coluna):
        """
        Executa uma jogada na posição indicada se estiver livre.

        Args:
            linha (int): Linha da jogada.
            coluna (int): Coluna da jogada.

        Returns:
            bool: True se a jogada foi realizada, False se a posição já estava ocupada.
        """
        if self.tabuleiro[linha][coluna] == ' ':
            self.tabuleiro[linha][coluna] = self.jogador_atual
            return True
        return False

    def desfazer_jogada(self, linha, coluna):
        """
        Desfaz uma jogada, limpando a posição indicada.

        Args:
            linha (int): Linha da jogada.
            coluna (int): Coluna da jogada.
        """
        self.tabuleiro[linha][coluna] = ' '

    def trocar_jogador(self):
        """
        Alterna o jogador atual entre 'X' e 'O'.
        """
        self.jogador_atual = 'O' if self.jogador_atual == 'X' else 'X'

    def verificar_vitoria(self):
        """
        Verifica se há um vencedor com 4 peças consecutivas.

        Returns:
            str or None: 'X' ou 'O' se houver vencedor, ou None caso contrário.
        """
        for linha in range(5):
            for coluna in range(5):
                if self.tabuleiro[linha][coluna] != ' ':
                    jogador = self.tabuleiro[linha][coluna]
                    # Verifica horizontal
                    if coluna + 3 < 5 and all(self.tabuleiro[linha][coluna + i] == jogador for i in range(4)):
                        return jogador
                    # Verifica vertical
                    if linha + 3 < 5 and all(self.tabuleiro[linha + i][coluna] == jogador for i in range(4)):
                        return jogador
                    # Diagonal \
                    if linha + 3 < 5 and coluna + 3 < 5 and all(self.tabuleiro[linha + i][coluna + i] == jogador for i in range(4)):
                        return jogador
                    # Diagonal /
                    if linha - 3 >= 0 and coluna + 3 < 5 and all(self.tabuleiro[linha - i][coluna + i] == jogador for i in range(4)):
                        return jogador
        return None

    def verificar_empate(self):
        """
        Verifica se o jogo terminou em empate (sem espaços e sem vencedor).

        Returns:
            bool: True se for empate, False caso contrário.
        """
        return all(self.tabuleiro[linha][coluna] != ' ' for linha in range(5) for coluna in range(5)) and self.verificar_vitoria() is None

    def contar_potenciais_vitoria(self, jogador):
      """
      Conta quantas sequências de 4 posições existem com 3 peças do jogador e 1 espaço vazio.
      """
      direções = [(0, 1), (1, 0), (1, 1), (-1, 1)]
      total = 0
      for linha in range(5):
          for coluna in range(5):
              for dx, dy in direções:
                  count = 0
                  vazio = 0
                  for i in range(4):
                      x = linha + dx * i
                      y = coluna + dy * i
                      if 0 <= x < 5 and 0 <= y < 5:
                          if self.tabuleiro[x][y] == jogador:
                              count += 1
                          elif self.tabuleiro[x][y] == ' ':
                              vazio += 1
                          else:
                              break
                      else:
                          break
                  if count == 3 and vazio == 1:
                      total += 1
      return total

    def contar_sequencias(self, jogador, tamanho):
        """
        Conta o número de sequências consecutivas de um jogador com tamanho especificado.

        Args:
            jogador (str): 'X' ou 'O'.
            tamanho (int): Tamanho da sequência a contar.

        Returns:
            int: Número de sequências encontradas.
        """
        direções = [(0, 1), (1, 0), (1, 1), (-1, 1)]
        total = 0
        for linha in range(5):
            for coluna in range(5):
                for dx, dy in direções:
                    count = 0
                    for i in range(tamanho):
                        x = linha + dx * i
                        y = coluna + dy * i
                        if 0 <= x < 5 and 0 <= y < 5 and self.tabuleiro[x][y] == jogador:
                            count += 1
                        else:
                            break
                    if count == tamanho:
                        total += 1
        return total

    def avaliar_tabuleiro(self):
      """
      Avalia o tabuleiro com múltiplas características.
      """
      if self.verificar_vitoria() == 'O':
          return float('inf')
      if self.verificar_vitoria() == 'X':
          return float('-inf')

      score = 0
      # Duplas e Trincas
      score += self.pesos['duplas'] * (self.contar_sequencias('O', 2) - self.contar_sequencias('X', 2))
      score += self.pesos['trincas'] * (self.contar_sequencias('O', 3) - self.contar_sequencias('X', 3))

      # Controle do centro
      centro = [(2, 2), (2, 1), (2, 3), (1, 2), (3, 2)]
      for linha, coluna in centro:
          if self.tabuleiro[linha][coluna] == 'O':
              score += self.pesos['centro']
          elif self.tabuleiro[linha][coluna] == 'X':
              score -= self.pesos['centro']

      # Potenciais de vitória
      score += self.pesos['potencial_vitoria'] * (
          self.contar_potenciais_vitoria('O') - self.contar_potenciais_vitoria('X')
      )

      return score

    def minmax(self, profundidade, alpha, beta, maximizando):
        """
        Implementa o algoritmo MinMax com poda alfa-beta.

        Args:
            profundidade (int): Nível de profundidade da busca.
            alpha (float): Valor alfa (melhor valor para o maximizador até agora).
            beta (float): Valor beta (melhor valor para o minimizador até agora).
            maximizando (bool): True se a IA está jogando, False se o jogador humano.

        Returns:
            tuple: (valor da avaliação, melhor jogada (linha, coluna)).
        """
        if profundidade == 0 or self.verificar_vitoria() or self.verificar_empate():
            return self.avaliar_tabuleiro(), None

        melhor_jogada = None
        if maximizando:
            max_avaliacao = float('-inf')
            for linha, coluna in self.ações_possíveis():
                self.tabuleiro[linha][coluna] = 'O'
                avaliacao, _ = self.minmax(profundidade - 1, alpha, beta, False)
                self.tabuleiro[linha][coluna] = ' '
                if avaliacao > max_avaliacao:
                    max_avaliacao = avaliacao
                    melhor_jogada = (linha, coluna)
                alpha = max(alpha, avaliacao)
                if beta <= alpha:
                    break  # Poda beta
            return max_avaliacao, melhor_jogada
        else:
            min_avaliacao = float('inf')
            for linha, coluna in self.ações_possíveis():
                self.tabuleiro[linha][coluna] = 'X'
                avaliacao, _ = self.minmax(profundidade - 1, alpha, beta, True)
                self.tabuleiro[linha][coluna] = ' '
                if avaliacao < min_avaliacao:
                    min_avaliacao = avaliacao
                    melhor_jogada = (linha, coluna)
                beta = min(beta, avaliacao)
                if beta <= alpha:
                    break  # Poda alfa
            return min_avaliacao, melhor_jogada

    def jogar(self):
        """
        Inicia o loop principal do jogo, alternando entre o jogador humano ('X')
        e a IA ('O') até que haja um vencedor ou ocorra empate.
        """
        while True:
            self.imprimir_tabuleiro()
            if self.jogador_atual == 'X':
                print(f"Jogador {self.jogador_atual}, suas opções de movimento: {self.ações_possíveis()}")
                try:
                    linha = int(input("Escolha uma linha (0-4): "))
                    coluna = int(input("Escolha uma coluna (0-4): "))
                    if not (0 <= linha < 5 and 0 <= coluna < 5):
                        print("Coordenadas fora do intervalo. Tente novamente.")
                        continue
                    if not self.fazer_jogada(linha, coluna):
                        print("Posição já ocupada. Tente novamente.")
                        continue
                except ValueError:
                    print("Entrada inválida. Por favor, insira números inteiros de 0 a 4.")
                    continue
            else:
                print("IA está pensando...")
                _, jogada = self.minmax(profundidade=4, alpha=float('-inf'), beta=float('inf'), maximizando=True)
                if jogada:
                    self.fazer_jogada(*jogada)
                    print(f"IA jogou na posição: {jogada}")

            vencedor = self.verificar_vitoria()
            if vencedor:
                self.imprimir_tabuleiro()
                print(f"Jogador {vencedor} venceu!")
                break

            if self.verificar_empate():
                self.imprimir_tabuleiro()
                print("Empate!")
                break

            self.trocar_jogador()

# Executa o jogo
jogo = Conecta4()
jogo.jogar()

import random

class AlgoritmoGenetico:
    def __init__(self, tamanho_populacao, taxa_crossover, taxa_mutacao, num_geracoes):
        self.tamanho_populacao = tamanho_populacao
        self.taxa_crossover = taxa_crossover
        self.taxa_mutacao = taxa_mutacao
        self.num_geracoes = num_geracoes
        self.populacao = self.gerar_populacao_inicial()

    def gerar_populacao_inicial(self):
        """
        Gera a população inicial com coeficientes aleatórios para a IA.
        """
        populacao = []
        for _ in range(self.tamanho_populacao):
            individuo = {
                'duplas': random.uniform(0.0, 5.0),
                'trincas': random.uniform(0.0, 5.0),
                'centro': random.uniform(0.0, 5.0),
                'potencial_vitoria': random.uniform(0.0, 5.0)
            }
            populacao.append(individuo)
        return populacao

    def calcular_fitness(self, individuo):
        """
        Calcula o fitness de um indivíduo (desempenho contra agente Min-Max).
        """
        jogo = Conecta4()
        jogo.pesos = individuo  # Definindo os pesos para a IA
        jogo.jogar()  # Simula uma partida contra o agente Min-Max (jogador humano)
        vitoria = jogo.verificar_vitoria()
        if vitoria == 'O':  # Se a IA venceu
            return 1
        elif jogo.verificar_empate():  # Se for empate
            return 0
        return -1  # Se a IA perdeu

    def selecionar_pais(self):
        """
        Seleciona os pais para o crossover usando torneio.
        """
        pais = random.sample(self.populacao, 2)  # Seleciona 4 indivíduos aleatórios
        fitness_pais = [self.calcular_fitness(pai) for pai in pais]
        melhor_pai = pais[fitness_pais.index(max(fitness_pais))]
        return melhor_pai

    def crossover(self, pai1, pai2):
        """
        Realiza o crossover entre dois pais para gerar dois filhos.
        """
        if random.random() < self.taxa_crossover:
            ponto_crossover = random.randint(0, 3)
            filho1 = pai1.copy()
            filho2 = pai2.copy()

            for key in list(filho1.keys())[ponto_crossover:]:
                filho1[key], filho2[key] = filho2[key], filho1[key]

            return filho1, filho2
        return pai1, pai2  # Se não houver crossover, retorna os pais inalterados

    def mutacao(self, individuo):
        """
        Aplica a mutação em um indivíduo com probabilidade.
        """
        if random.random() < self.taxa_mutacao:
            chave = random.choice(list(individuo.keys()))
            individuo[chave] = random.uniform(0.0, 5.0)  # Altera o valor do coeficiente escolhido
        return individuo

    def evoluir(self):
        """
        Realiza o processo de evolução para otimizar os coeficientes.
        """
        for geracao in range(self.num_geracoes):
            nova_populacao = []
            while len(nova_populacao) < self.tamanho_populacao:
                pai1 = self.selecionar_pais()
                pai2 = self.selecionar_pais()
                filho1, filho2 = self.crossover(pai1, pai2)
                nova_populacao.append(self.mutacao(filho1))
                nova_populacao.append(self.mutacao(filho2))

            self.populacao = nova_populacao  # Atualiza a população com os novos indivíduos

            # Exibe a melhor solução da geração
            melhor_individuo = max(self.populacao, key=self.calcular_fitness)
            print(f"Geração {geracao + 1}: Melhor fitness = {self.calcular_fitness(melhor_individuo)}")

# Parâmetros do Algoritmo Genético
algoritmo_genetico = AlgoritmoGenetico(
    tamanho_populacao=2,
    taxa_crossover=0.7,
    taxa_mutacao=0.1,
    num_geracoes=1
)

# Evoluir a população
algoritmo_genetico.evoluir()